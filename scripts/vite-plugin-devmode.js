/**
 * Vite Plugin: Dev Mode Hot Reload
 *
 * ê°œë°œ ëª¨ë“œì—ì„œ Hot Reloadë¥¼ ìœ„í•œ WebSocket í´ë¼ì´ì–¸íŠ¸ ì½”ë“œë¥¼ ìë™ ìƒì„±í•©ë‹ˆë‹¤.
 * Webpackì˜ DevModeWebpackPluginê³¼ ë™ì¼í•œ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.
 */

import fs from 'fs';
import path from 'path';

export function vitePluginDevMode(options = {}) {
  const {
    defaultPort = 13131,
    portFilePath = path.resolve(process.cwd(), '.dev-server-port'),
    outputFilePath = path.resolve(process.cwd(), 'src/core/dev-reload.js'),
    useCaddy = false,
    caddyDomain = ''
  } = options;

  // Read plugin name from package.json for log identification
  let pluginName = 'unknown-plugin';
  try {
    const pkgPath = path.resolve(process.cwd(), 'package.json');
    const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf-8'));
    pluginName = pkg.name || 'unknown-plugin';
  } catch (error) {
    console.warn('[vite-plugin-devmode] Failed to read package.json:', error.message);
  }

  let isDevelopment = false;

  return {
    name: 'vite-plugin-devmode',
 
    config(config, { mode }) {
      isDevelopment = mode === 'development' || process.env.NODE_ENV === 'development';
    },

    // ë¹Œë“œ ì‹œì‘ ì „ì— ì‹¤í–‰
    buildStart() {
      if (isDevelopment) {
        generateDevReloadFile();
      } else {
        // í”„ë¡œë•ì…˜ ë¹Œë“œ ì‹œ dev-reload.js ì‚­ì œ
        if (fs.existsSync(outputFilePath)) {
          fs.unlinkSync(outputFilePath);
          console.log(`[${pluginName}:vite-plugin-devmode] ğŸ—‘ï¸  Removed dev-reload.js (production build)`);
        }
      }
    },

    // Watch ëª¨ë“œì—ì„œ íŒŒì¼ ë³€ê²½ ê°ì§€
    configureServer(server) {
      if (!isDevelopment) return;

      // .dev-server-port íŒŒì¼ ë³€ê²½ ê°ì§€
      server.watcher.add(portFilePath);

      server.watcher.on('change', (file) => {
        if (file === portFilePath) {
          console.log(`[${pluginName}:vite-plugin-devmode] ğŸ”Œ dev-server-port changed, regenerating dev-reload.js...`);
          generateDevReloadFile();
          // HMR íŠ¸ë¦¬ê±°
          server.ws.send({ type: 'full-reload' });
        }
      });
    }
  };

  function generateDevReloadFile() {
    try {
      // .dev-server-port íŒŒì¼ì—ì„œ í¬íŠ¸ ì½ê¸°
      let port = defaultPort;
      if (fs.existsSync(portFilePath)) {
        const portStr = fs.readFileSync(portFilePath, 'utf-8').trim();
        port = parseInt(portStr, 10) || defaultPort;
      }

      // WebSocket URL ìƒì„± (Caddy ì‚¬ìš© ì‹œ wss://{domain}/ws, ì•„ë‹ˆë©´ ws://localhost:{port})
      const wsUrl = useCaddy && caddyDomain
        ? `wss://${caddyDomain}/ws`
        : `ws://localhost:${port}`;

      // src/core/dev-reload.js ìƒì„± (webpack ë²„ì „ê³¼ ë™ì¼í•œ ê¸°ëŠ¥)
      const devReloadContent = `/**
 * Auto-generated Hot Reload Client
 *
 * DO NOT EDIT THIS FILE MANUALLY!
 * This file is automatically generated in development mode.
 *
 * WebSocket URL: ${wsUrl}
 */

import { parsePluginScript, scriptUpdater } from './script-updater.js';
import { PLUGIN_NAME } from '../constants.js';
const DEV_SERVER_URL = '${wsUrl}';
const MAX_RECONNECT_DELAY = 30000; // 30 seconds
const INITIAL_RECONNECT_DELAY = 1000; // 1 second
const MAX_ERROR_LOGS = 3; // Maximum error logs to display
const MAX_RECONNECT_ATTEMPTS = 3; // Stop reconnecting after 3 attempts

class HotReloadClient {
  constructor() {
    this.ws = null;
    this.reconnectAttempts = 0;
    this.reconnectTimeout = null;
    this.isIntentionallyClosed = false;
    this.errorLogCount = 0; // Track error log count
  }

  /**
   * Initialize WebSocket connection
   */
  connect() {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      console.log(\`[\${PLUGIN_NAME}:HotReload] Already connected\`);
      return;
    }

    try {
      if (this.errorLogCount < MAX_ERROR_LOGS) {
        console.log(\`[\${PLUGIN_NAME}:HotReload] Connecting to dev server:\`, DEV_SERVER_URL);
      }
      this.ws = new WebSocket(DEV_SERVER_URL);

      this.ws.onopen = () => {
        console.log(\`[\${PLUGIN_NAME}:HotReload] âœ… Connected to dev server\`);
        this.reconnectAttempts = 0; // Reset on successful connection
        this.errorLogCount = 0; // Reset error log count on successful connection
      };

      this.ws.onmessage = (event) => {
        this.handleMessage(event.data);
      };

      this.ws.onclose = (event) => {
        if (this.errorLogCount < MAX_ERROR_LOGS) {
          console.log(\`[\${PLUGIN_NAME}:HotReload] Disconnected (code: \${event.code}, reason: \${event.reason || 'unknown'})\`);
          this.errorLogCount++;
        } else if (this.errorLogCount === MAX_ERROR_LOGS) {
          console.log(\`[\${PLUGIN_NAME}:HotReload] Connection errors suppressed (max logs reached). Retrying silently...\`);
          this.errorLogCount++;
        }

        if (!this.isIntentionallyClosed) {
          this.scheduleReconnect();
        }
      };

      this.ws.onerror = (error) => {
        // Silently handle WebSocket errors during development
        // Connection issues are expected when dev server is not running
      };

    } catch (error) {
      // Silently handle connection failures during development
      // Connection issues are expected when dev server is not running
      if (this.errorLogCount < MAX_ERROR_LOGS) {
        this.errorLogCount++;
      }
      this.scheduleReconnect();
    }
  }

  /**
   * Handle incoming messages from dev server
   * @param {string} data - Raw message data
   */
  handleMessage(data) {
    try {
      const message = JSON.parse(data);

      switch (message.type) {
        case 'connected':
          console.log(\`[\${PLUGIN_NAME}:HotReload] Server message:\`, message.message);
          break;

        case 'reload':
          console.log(\`[\${PLUGIN_NAME}:HotReload] ğŸ“¦ Update received (\${message.file}, \${message.size} bytes)\`);
          this.handleReload(message.scriptContent);
          break;

        case 'pong':
          // Heartbeat response (optional)
          break;

        default:
          console.warn(\`[\${PLUGIN_NAME}:HotReload] Unknown message type:\`, message.type);
      }
    } catch (error) {
      console.error(\`[\${PLUGIN_NAME}:HotReload] Failed to parse message:\`, error);
    }
  }

  /**
   * Extract plugin name from banner
   * @param {string} scriptContent - Script content
   * @returns {string|null} - Plugin name or null
   */
  extractPluginName(scriptContent) {
    try {
      // Extract banner name from script content
      const bannerRegex = /\\/\\/@name (.+?)\\n/;
      const match = scriptContent.match(bannerRegex);
      return match ? match[1].trim() : null;
    } catch (error) {
      console.error(\`[\${PLUGIN_NAME}:HotReload] Failed to extract plugin name:\`, error);
      return null;
    }
  }

  /**
   * Handle script reload
   * @param {string} scriptContent - Updated script content
   */
  async handleReload(scriptContent) {
    try {
      console.log(\`[\${PLUGIN_NAME}:HotReload] ğŸ”„ Parsing updated script...\`);

      // Security Check: Verify plugin name matches
      const receivedPluginName = this.extractPluginName(scriptContent);
      const currentPluginName = PLUGIN_NAME;

      if (!receivedPluginName) {
        console.error(\`[\${PLUGIN_NAME}:HotReload] âŒ Security Check Failed: No plugin name found in received script\`);
        this.showToast('âŒ Security Check Failed: Invalid script format', 'error');
        return;
      }

      if (receivedPluginName !== currentPluginName) {
        console.error(
          \`[\${PLUGIN_NAME}:HotReload] âŒ Security Check Failed: Plugin name mismatch\\n\` +
          \`  Expected: \${currentPluginName}\\n\` +
          \`  Received: \${receivedPluginName}\`
        );
        this.showToast(
          \`âŒ Security Check Failed: Wrong plugin (\${receivedPluginName})\`,
          'error'
        );
        return;
      }

      console.log(\`[\${PLUGIN_NAME}:HotReload] âœ… Security Check Passed: Plugin name verified (\${currentPluginName})\`);

      // Parse using existing script-updater logic
      const parsed = parsePluginScript(scriptContent);

      console.log(\`[\${PLUGIN_NAME}:HotReload] ğŸ”„ Updating plugin...\`);
      const result = await scriptUpdater(parsed);

      if (result.success) {
        console.log(\`[\${PLUGIN_NAME}:HotReload] âœ… Plugin updated successfully\`);

        // Show toast notification instead of auto-reload
        this.showToast('ğŸ”¥ Hot Reload Complete!', 'success');
      } else {
        console.error(\`[\${PLUGIN_NAME}:HotReload] âŒ Plugin update failed:\`, result.error);
        this.showToast(\`âŒ Hot Reload Failed: \${result.error?.message || 'Unknown error'}\`, 'error');
      }
    } catch (error) {
      console.error(\`[\${PLUGIN_NAME}:HotReload] âŒ Reload failed:\`, error);
      this.showToast(\`âŒ Hot Reload Error: \${error.message}\`, 'error');
    }
  }

  /**
   * Show toast notification
   * @param {string} message - Toast message
   * @param {string} type - Toast type ('success' or 'error')
   */
  showToast(message, type = 'success') {
    // Remove existing toast if any
    const existingToast = document.getElementById('hot-reload-toast');
    if (existingToast) {
      existingToast.remove();
    }

    // Create toast element
    const toast = document.createElement('div');
    toast.id = 'hot-reload-toast';
    toast.textContent = message;

    // Apply styles
    const bgColor = type === 'success' ? '#10b981' : '#ef4444';
    Object.assign(toast.style, {
      position: 'fixed',
      top: '-100px', // Start above viewport
      left: '50%',
      transform: 'translateX(-50%)',
      backgroundColor: bgColor,
      color: 'white',
      padding: '12px 24px',
      borderRadius: '8px',
      boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1), 0 2px 4px rgba(0, 0, 0, 0.06)',
      fontSize: '14px',
      fontWeight: '500',
      zIndex: '999999',
      transition: 'top 0.3s ease-out',
      fontFamily: 'system-ui, -apple-system, sans-serif',
    });

    // Append to body
    document.body.appendChild(toast);

    // Trigger slide down animation
    setTimeout(() => {
      toast.style.top = '20px';
    }, 10);

    // Auto remove after 3 seconds
    setTimeout(() => {
      toast.style.top = '-100px';
      setTimeout(() => {
        toast.remove();
      }, 300); // Wait for slide up animation
    }, 3000);
  }

  /**
   * Schedule reconnection with exponential backoff
   */
  scheduleReconnect() {
    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout);
    }

    // Stop reconnecting after MAX_RECONNECT_ATTEMPTS
    if (this.reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
      if (this.errorLogCount < MAX_ERROR_LOGS) {
        console.log(\`[\${PLUGIN_NAME}:HotReload] Max reconnection attempts reached. Stopped retrying.\`);
      }
      return;
    }

    // Exponential backoff: 1s, 2s, 4s, 8s, 16s, 30s (max)
    const delay = Math.min(
      INITIAL_RECONNECT_DELAY * Math.pow(2, this.reconnectAttempts),
      MAX_RECONNECT_DELAY
    );

    if (this.errorLogCount < MAX_ERROR_LOGS) {
      console.log(\`[\${PLUGIN_NAME}:HotReload] Reconnecting in \${delay / 1000}s... (attempt \${this.reconnectAttempts + 1})\`);
    }

    this.reconnectTimeout = setTimeout(() => {
      this.reconnectAttempts++;
      this.connect();
    }, delay);
  }

  /**
   * Send ping to server (optional heartbeat)
   */
  ping() {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify({ type: 'ping', timestamp: Date.now() }));
    }
  }

  /**
   * Disconnect from server
   */
  disconnect() {
    this.isIntentionallyClosed = true;

    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout);
    }

    if (this.ws) {
      this.ws.close(1000, 'Client closed');
      this.ws = null;
    }

    console.log(\`[\${PLUGIN_NAME}:HotReload] Disconnected\`);
  }
}

// Singleton instance
let hotReloadClient = null;

/**
 * Initialize hot reload client
 */
export function initHotReload() {
  if (hotReloadClient) {
    console.log(\`[\${PLUGIN_NAME}:HotReload] Already initialized\`);
    return hotReloadClient;
  }

  console.log(\`[\${PLUGIN_NAME}:HotReload] ğŸ”¥ Initializing hot reload client...\`);
  hotReloadClient = new HotReloadClient();
  hotReloadClient.connect();

  // Optional: Send ping every 30 seconds to keep connection alive
  setInterval(() => {
    hotReloadClient.ping();
  }, 30000);

  return hotReloadClient;
}

/**
 * Disconnect hot reload client
 */
export function stopHotReload() {
  if (hotReloadClient) {
    hotReloadClient.disconnect();
    hotReloadClient = null;
  }
}
`;

      // ë””ë ‰í† ë¦¬ ìƒì„± (ì—†ìœ¼ë©´)
      const outputDir = path.dirname(outputFilePath);
      if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
      }

      // íŒŒì¼ì´ ì´ë¯¸ ì¡´ì¬í•˜ê³  ë‚´ìš©ì´ ê°™ìœ¼ë©´ ì“°ì§€ ì•ŠìŒ (ë¬´í•œ ë£¨í”„ ë°©ì§€)
      if (fs.existsSync(outputFilePath)) {
        const existingContent = fs.readFileSync(outputFilePath, 'utf-8');
        if (existingContent === devReloadContent) {
          // ë‚´ìš©ì´ ê°™ìœ¼ë©´ íŒŒì¼ì„ ë‹¤ì‹œ ì“°ì§€ ì•ŠìŒ
          return;
        }
      }

      fs.writeFileSync(outputFilePath, devReloadContent, 'utf-8');
      console.log(`[${pluginName}:vite-plugin-devmode] âœ… Generated dev-reload.js (${wsUrl})`);
    } catch (error) {
      console.error(`[${pluginName}:vite-plugin-devmode] âŒ Failed to generate dev-reload.js:`, error);
    }
  }
}

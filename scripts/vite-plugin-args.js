/**
 * Vite Plugin: Plugin Args Generator
 *
 * plugin-args.jsonì„ ì½ì–´ì„œ src/core/plugin-config.jsë¥¼ ìžë™ ìƒì„±í•©ë‹ˆë‹¤.
 * Webpackì˜ PluginArgsWebpackPluginê³¼ ë™ì¼í•œ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.
 */

import fs from 'fs';
import path from 'path';

export function vitePluginArgs(options = {}) {
  const {
    argsFilePath = path.resolve(process.cwd(), 'src/plugin-args.json'),
    outputFilePath = path.resolve(process.cwd(), 'src/core/plugin-config.js')
  } = options;

  return {
    name: 'vite-plugin-args',

    // ë¹Œë“œ ì‹œìž‘ ì „ì— ì‹¤í–‰
    buildStart() {
      generatePluginConfig();
    },

    // Watch ëª¨ë“œì—ì„œ íŒŒì¼ ë³€ê²½ ê°ì§€
    configureServer(server) {
      // plugin-args.json ë³€ê²½ ê°ì§€
      server.watcher.add(argsFilePath);

      server.watcher.on('change', (file) => {
        if (file === argsFilePath) {
          console.log('ðŸ“ plugin-args.json changed, regenerating plugin-config.js...');
          generatePluginConfig();
          // HMR íŠ¸ë¦¬ê±°
          server.ws.send({ type: 'full-reload' });
        }
      });
    }
  };

  function generatePluginConfig() {
    try {
      // plugin-args.json ì½ê¸°
      if (!fs.existsSync(argsFilePath)) {
        console.warn(`âš ï¸  ${argsFilePath} not found, skipping plugin-config.js generation`);
        return;
      }

      const argsConfig = JSON.parse(fs.readFileSync(argsFilePath, 'utf-8'));
      const args = argsConfig.args || [];

      if (args.length === 0) {
        console.warn('[vite-plugin-args] No args defined in plugin-args.json.');
        return;
      }

      // PluginArgs í´ëž˜ìŠ¤ ì½”ë“œ ìƒì„±
      const code = generateCode(args);

      // ê¸°ì¡´ íŒŒì¼ ë‚´ìš©ê³¼ ë¹„êµ (ë¬´í•œ ë£¨í”„ ë°©ì§€)
      if (fs.existsSync(outputFilePath)) {
        const existingContent = fs.readFileSync(outputFilePath, 'utf-8');
        if (existingContent === code) {
          // ë‚´ìš©ì´ ë™ì¼í•˜ë©´ íŒŒì¼ì„ ì“°ì§€ ì•ŠìŒ
          return;
        }
      }

      // ë””ë ‰í† ë¦¬ ìƒì„± (ì—†ìœ¼ë©´)
      const outputDir = path.dirname(outputFilePath);
      if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
      }

      fs.writeFileSync(outputFilePath, code, 'utf-8');
      console.log(`âœ… Generated plugin-config.js from plugin-args.json`);
    } catch (error) {
      console.error('âŒ Failed to generate plugin-config.js:', error);
    }
  }

  /**
   * Generate PluginArgs class code
   * @param {Array} args - Array of arg definitions
   * @returns {string} Generated JavaScript code
   */
  function generateCode(args) {
    const getters = args.map(arg => generateGetter(arg)).join('\n\n');
    const setters = args.map(arg => generateSetter(arg)).join('\n\n');

    return `/**
 * Auto-generated Plugin Arguments Configuration
 *
 * DO NOT EDIT THIS FILE MANUALLY!
 * This file is automatically generated from src/plugin-args.json during build.
 *
 * To add/modify plugin arguments:
 * 1. Edit src/plugin-args.json
 * 2. Run npm run build
 * 3. This file will be regenerated automatically
 */

import { PLUGIN_NAME } from '../constants.js';
import { RisuAPI } from './risu-api.js';

/**
 * Plugin Arguments Helper Class
 * Provides convenient getter/setter access to RisuAI plugin arguments with caching.
 * Automatically uses RisuAPI singleton instance.
 *
 * @example
 * import { PluginArgs } from './core/plugin-config.js';
 *
 * const args = new PluginArgs();
 *
 * // Getter
 * const apiKey = args.exampleApiKey;
 *
 * // Setter
 * args.maxTokens = 4096;
 *
 * // Cache invalidation
 * args.invalidate('exampleApiKey');
 */
export class PluginArgs {
  /**
   * @param {Object} [risuAPI] - RisuAPI instance (optional, uses singleton if not provided)
   */
  constructor(risuAPI = null) {
    // Use singleton instance if not provided
    this._api = risuAPI || RisuAPI.getInstance();
    this._cache = new Map();
    this._ttl = 5000; // Cache TTL in milliseconds (5 seconds)
    this._timestamps = new Map();
  }

  // ==================== Auto-generated Getters ====================

${getters}

  // ==================== Auto-generated Setters ====================

${setters}

  // ==================== Private Helper Methods ====================

  /**
   * Get argument value with caching
   * @private
   * @param {string} name - Argument name
   * @param {string|number} defaultValue - Default value
   * @returns {string|number} Argument value
   */
  _get(name, defaultValue) {
    const key = \`\${PLUGIN_NAME}::\${name}\`;
    const now = Date.now();

    // Check cache validity
    if (this._cache.has(key)) {
      const timestamp = this._timestamps.get(key);
      if (timestamp && (now - timestamp) < this._ttl) {
        return this._cache.get(key);
      }
    }

    // Fetch from API
    const value = this._api.getArg(key) ?? defaultValue;
    this._cache.set(key, value);
    this._timestamps.set(key, now);
    return value;
  }

  /**
   * Set argument value and update cache
   * @private
   * @param {string} name - Argument name
   * @param {string|number} value - Argument value
   */
  _set(name, value) {
    const key = \`\${PLUGIN_NAME}::\${name}\`;
    this._api.setArg(key, value);
    this._cache.set(key, value);
    this._timestamps.set(key, Date.now());
  }

  // ==================== Public Cache Management ====================

  /**
   * Invalidate cache for a specific argument
   * @param {string} name - Argument name
   */
  invalidate(name) {
    const key = \`\${PLUGIN_NAME}::\${name}\`;
    this._cache.delete(key);
    this._timestamps.delete(key);
  }

  /**
   * Clear all cached values
   */
  clearCache() {
    this._cache.clear();
    this._timestamps.clear();
  }

  /**
   * Set cache TTL (Time To Live)
   * @param {number} ttl - TTL in milliseconds
   */
  setCacheTTL(ttl) {
    if (typeof ttl !== 'number' || ttl < 0) {
      throw new Error('TTL must be a non-negative number');
    }
    this._ttl = ttl;
  }

  /**
   * Get all cached argument names
   * @returns {string[]} Array of cached argument names
   */
  getCachedArgs() {
    return Array.from(this._cache.keys()).map(key => key.replace(\`\${PLUGIN_NAME}::\`, ''));
  }
}
`;
  }

  /**
   * Generate getter code for an argument
   * @param {Object} arg - Argument definition
   * @returns {string} Getter code
   */
  function generateGetter(arg) {
    const { name, type, default: defaultValue, description } = arg;
    const jsDefault = type === 'int' ? defaultValue : JSON.stringify(defaultValue);

    return `  /**
   * Get ${name}
   * ${description}
   * @type {${type === 'int' ? 'number' : 'string'}}
   */
  get ${name}() {
    return this._get('${name}', ${jsDefault});
  }`;
  }

  /**
   * Generate setter code for an argument
   * @param {Object} arg - Argument definition
   * @returns {string} Setter code
   */
  function generateSetter(arg) {
    const { name, type, description } = arg;
    const validation = type === 'int'
      ? `    if (typeof value !== 'number') {
      throw new TypeError('${name} must be a number');
    }`
      : `    if (typeof value !== 'string') {
      throw new TypeError('${name} must be a string');
    }`;

    return `  /**
   * Set ${name}
   * ${description}
   * @param {${type === 'int' ? 'number' : 'string'}} value - New value
   */
  set ${name}(value) {
${validation}
    this._set('${name}', value);
  }`;
  }
}
